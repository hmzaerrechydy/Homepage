
    <!DOCTYPE html>
    <html>
        <head>
          <title>
            Hamza Errechydy
          </title>
          <link rel="stylesheet" href="../style.css">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
          <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">  
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">            
        </head>
        <body>
        <article id = "post">
          <button  class="btn btn-light">
            <a href="../blog.html">
              <i class="bi bi-arrow-left"></i> Other Posts 
            </a>
          </button>
          <br />
          <h1>CS50 Lab 5</h1>
          <br/>
            <p>Link: <a href="https://cs50.harvard.edu/x/2023/labs/5/">https://cs50.harvard.edu/x/2023/labs/5/</a></p>
<p>A person’s blood type is determined by two alleles (i.e., different forms of a gene). The three possible alleles are A, B, and O, of which each person has two (possibly the same, possibly different).</p>
<p>Each of a child’s parents randomly passes one of their two blood type alleles to their child.</p>
<p>The possible blood type combinations, then, are: OO, OA, OB, AO, AA, AB, BO, BA, and BB.</p>
<p>For example, if one parent has blood type AO and the other parent has blood type BB, then the child’s possible blood types would be AB and OB, depending on which allele is received from each parent. Similarly, if one parent has blood type AO and the other OB, then the child’s possible blood types would be AO, OB, AB, and OO.</p>
<pre><code class="c language-c">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
</code></pre>
<p>We include header files that contains prototypes of functions written by other people that we can use in this program.</p>
<pre><code class="c language-c">// Each person has two parents and two alleles
typedef struct person
{
    struct person *parents[2];
    char alleles[2];
}
person;
</code></pre>
<p>We created a person data structure that contains two properties: a pointer to another two persons and a char variable to store the two alleles values of that person blood type.</p>
<p>Notice the definition of a type called person. Each person has an array of two parents, each of which is a pointer to another person struct. Each person also has an array of two alleles, each of which is a char (either 'A', 'B', or 'O').</p>
<pre><code class="c language-c">person *create_family(int generations);
void print_family(person *p, int generation);
void free_family(person *p);
char random_allele();
</code></pre>
<p>Those are prototypes of functions that we declared and used later on in the program.</p>
<pre><code class="c language-c">// Seed random number generator
    srand(time(0));
</code></pre>
<p>Pseudo-random number generators work by performing some operation on a value. Generally this value is the previous number generated by the generator. However, the first time you use the generator, there is no previous value.</p>
<p>Seeding a pseudo-random number generator gives it its first "previous" value. Each seed value will correspond to a sequence of generated values for a given random number generator. That is, if you provide the same seed twice, you get the same sequence of numbers twice.</p>
<p>Generally, you want to seed your random number generator with some value that will change each execution of the program. For instance, the current time is a frequently-used seed. The reason why this doesn't happen automatically is so that if you want, you can provide a specific seed to get a known sequence of numbers.</p>
<p>time(0) returns the system time in seconds since (00:00:00 UTC, January 1, 1970).</p>
<p>The main function then calls the create_family function to simulate the creation of person structs for a family of 3 generations (i.e. a person, their parents, and their grandparents).</p>
<p>For example, create_family(3) should return a pointer to a person with two parents, where each parent also has two parents.</p>
<p>Each person should have alleles assigned to them. The oldest generation should have alleles randomly chosen (as by calling the random_allele function), and younger generations should inherit one allele (chosen at random) from each parent.</p>
<p>Each person should have parents assigned to them. The oldest generation should have both parents set to NULL, and younger generations should have parents be an array of two pointers, each pointing to a different parent.</p>
<p>We’ve divided the create_family function into a few TODOs for you to complete:</p>
<p>First, you should allocate memory for a new person. Recall that you can use malloc to allocate memory, and sizeof(person) to get the number of bytes to allocate.</p>
<p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3fef49a9-3c8e-4fe6-a995-649d007c1c4a/Screenshot_from_2023-07-27_14-21-43.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230819%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230819T100113Z&X-Amz-Expires=3600&X-Amz-Signature=6d0f70e9607c9c2740d6dfaccba614b5d4f12b3b60451adbfbb087fc06bfcb42&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Screenshot_from_2023-07-27_14-21-43.png" /></p>
<p>The create<em>family function first creates a person, then if generations is bigger than 1 then we need parents for this person, an older generation, we do that by recursively using create</em>family, in other words this function creates a person, then add two parents to this person, and because we are using recursion each parent is a person the function creates and checks if generation is bigger than 1 if so it creates a another two parents for this parent or person.</p>
<p>Otherwise (if generations == 1), then there will be no parent data for this person. Both parents of your new person should be set to NULL, and each allele should be generated randomly.</p>
<pre><code class="c language-c">person *p = malloc(sizeof(person));
</code></pre>
<p>We allocate (give or dedicate) memory for a person, p is a pointer to this person in memory.</p>
<pre><code class="c language-c">person *parent0 = create_family(generations - 1);
person *parent1 = create_family(generations - 1);

// TODO: Set parent pointers for current person
p-&gt;parent0 = parent0;
p-&gt;parent1 = parent1;
</code></pre>
<p>We create two parents and assign each parent to person.</p>
<pre><code class="c language-c">// TODO: Randomly assign current person's alleles based on the alleles of their parents
p-&gt;alleles[0] = p-&gt;parents[0]-&gt;alleles[rand() % 2];
p-&gt;alleles[1] = p-&gt;parents[1]-&gt;alleles[rand() % 2];
</code></pre>
<p>We randomly using rand() give both alleles of person two alleles from the parents.</p>
<pre><code class="c language-c">// If there are no generations left to create
    else
    {
        // TODO: Set parent pointers to NULL
        p-&gt;parents[0] = NULL;
        p-&gt;parents[1] = NULL;
        // TODO: Randomly assign alleles
        p-&gt;alleles[0] = random_allele();
        p-&gt;alleles[1] = random_allele();
    }
</code></pre>
<p>else if there are no more generations to create then we set person's (grandparents) parents to NULL and randomly using random_allele() assign to person two alleles.</p>
<pre><code class="c language-c">// TODO: Return newly created person
    return p;
</code></pre>
<p>Finally we return the newly created person.</p>
<pre><code class="c language-c">// Free `p` and all ancestors of `p`.
void free_family(person *p)
{
    // TODO: Handle base case
    if(p == NULL){
        return;
    }
    // TODO: Free parents recursively
    free_family(p-&gt;parents[0]);
    free_family(p-&gt;parents[1]);
    // TODO: Free child
    free(p);
}
</code></pre>
<p>Because we are using malloc() to use chunks of the computer's memory to store person we need to free those chunks of memory afterward, we pass person as an argument and we check whether it's NULL if so then we don't have no more person structs to free, if not then we recursively use free_family() on this person parents to either free those persons or stop the function if they are NULL which means we free the children, parents and grandparents, remember that grandparent's parents point to or equal NULL.</p>
<p>Here's how the print_family() function works:</p>
<p>It takes two arguments: p is a pointer to the child person in memory, and this child person also points to parents persons and those parents have parents, and so on based on the number of generations we have in the case of this program it's 3 as we declared on line 16 in the GENERATIONS variable. The second argument is generation which we will use to count up to the number of generations we have.</p>
<pre><code class="c language-c">    // Handle base case
    if (p == NULL)
    {
        return;
    }
</code></pre>
<p>In case person  or p is NULL then we want to stop running the function.</p>
<pre><code class="c language-c">    // Print indentation
    for (int i = 0; i &lt; generation * INDENT_LENGTH; i++)
    {
        printf(" ");
    }
</code></pre>
<p>Print indentation (free space) generation * INDENT_LENGTH which is a variable we declared in line 17 and it's assigned to 4, the first time the function uses this loop it prints 0 indentation because generation is set to 0, 0 * 4 returns 0, which means the loop will not run, in the second recursive use we will add 1 to generation, 1 * 4 is 4, so the loop will print 4 indentations, then 8 next time, and so on based on the number of generation we will cover in this function.</p>
<pre><code class="c language-c">// Print person
    if (generation == 0)
    {
        printf("Child (Generation %i): blood type %c%c\\n", generation, p-&gt;alleles[0], p-&gt;alleles[1]);
    }
</code></pre>
<p>if generation is 0 then it's the child person, in that case print the generation and blood type of it by accessing it's alleles array.</p>
<pre><code class="c language-c">else if (generation == 1)
    {
        printf("Parent (Generation %i): blood type %c%c\\n", generation, p-&gt;alleles[0], p-&gt;alleles[1]);
    }
</code></pre>
<p>In case generation is 1 we print the parent's generation and blood type.</p>
<pre><code class="c language-c">else
    {
        for (int i = 0; i &lt; generation - 2; i++)
        {
            printf("Great-");
        }
        printf("Grandparent (Generation %i): blood type %c%c\\n", generation, p-&gt;alleles[0], p-&gt;alleles[1]);
    }
</code></pre>
<p>else it's a grandparent so we print it's generation and blood type, in case we have more than 3 generation we will print Great- in front of Grandparent.</p>
<p>We will keep adding Great- in front of Grandparent generation - 2 times for each person in those older generations.</p>
<p>For example if we have 4 generations this loop will not work until the fourth generation, when the generation variable is 3 (remember we start counting from 0 not 1) 3 - 2 is 1 so for the current person this loop will work only once to add one Great- in front of Grandparent:</p>
<p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/18c6bfb0-1b2f-4684-bb28-1d21430f291b/Screenshot_from_2023-07-27_06-39-06.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230819%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230819T100116Z&X-Amz-Expires=3600&X-Amz-Signature=f37e1acb3ed3bfe2f6bbe93f97ef29909cd06b425cd75d5ff5761521e2e20b9f&X-Amz-SignedHeaders=host&x-id=GetObject" alt="Screenshot_from_2023-07-27_06-39-06.png" /></p>
<pre><code class="c language-c">// Print parents of current generation
    print_family(p-&gt;parents[0], generation + 1);
    print_family(p-&gt;parents[1], generation + 1);
</code></pre>
<p>Using recursion we call the print_family() function on parents[0] and parents[1], we check if person is NULL, if not we print it's indentation  and print the generation and blood type and again use recursion to access the parents of that parent.</p>
<pre><code class="c language-c">// Randomly chooses a blood type allele.
char random_allele()
{
    int r = rand() % 3;
    if (r == 0)
    {
        return 'A';
    }
    else if (r == 1)
    {
        return 'B';
    }
    else
    {
        return 'O';
    }
}
</code></pre>
<p>In variable r we generate a random number (0, 1 or 2) using rand() % 3.</p>
<p>Then based on the random returned number we return a, allele letter A, B or O.</p>
<h3 id="resources">Resources:</h3>
<ul>
<li><a href="https://stackoverflow.com/questions/22639587/random-seed-what-does-it-do">random.seed(): What does it do?</a></li>
</ul>
        </article>
        </body>
    </html>
    